package main

import (
	"context"
	"fmt"
	"log"
	"net"

	"github.com/honeycombio/beeline-go"
	"github.com/honeycombio/beeline-go/trace"
	"github.com/honeycombio/beeline-go/wrappers/hnygrpc"
	"google.golang.org/grpc"

	hpb "github.com/honeycombio/beeline-go/examples/grpc/proto"
)

type helloServer struct {
	hpb.UnimplementedHelloServiceServer
}

func (hs *helloServer) SayHello(ctx context.Context, req *hpb.HelloRequest) (*hpb.HelloResponse, error) {
	return &hpb.HelloResponse{Greeting: fmt.Sprintf("Hello, %s!", req.GetName())}, nil
}

func main() {
	// Initialize beeline. The only required field is WriteKey.
	beeline.Init(beeline.Config{
		WriteKey:    "example",
		Dataset:     "beeline-example",
		ServiceName: "sample app",
		// For demonstration, send the event to STDOUT instead of Honeycomb.
		// Remove the STDOUT setting when filling in a real write key.
		// NOTE: This should *only* be set to true in development environments.
		// Setting to true in Production environments can cause problems.
		STDOUT: true,
	})
	defer beeline.Close()

	// Set up a gRPC server.
	ln, err := net.Listen("tcp", ":50051")
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}
	serverOpts := []grpc.ServerOption{
		grpc.UnaryInterceptor(hnygrpc.UnaryServerInterceptor()),
	}
	s := grpc.NewServer(serverOpts...)
	hpb.RegisterHelloServiceServer(s, &helloServer{})
	go s.Serve(ln)

	// Set up a gRPC client.
	conn, err := grpc.Dial(
		"localhost:50051",
		grpc.WithInsecure(),
		grpc.WithBlock(),
		grpc.WithUnaryInterceptor(hnygrpc.UnaryClientInterceptor()),
	)
	if err != nil {
		log.Fatalf("did not connect: %v", err)
	}
	defer conn.Close()
	c := hpb.NewHelloServiceClient(conn)

	// Set up a root trace, so we can see it get propagated across the gRPC boundary.
	ctx := context.Background()
	ctx, tr := trace.NewTrace(ctx, nil)
	defer tr.Send()

	// Finally, make a call.
	req := &hpb.HelloRequest{Name: "Foo"}
	fmt.Printf("Making request: %v\n", req)
	res, err := c.SayHello(ctx, req)
	if err != nil {
		fmt.Printf("gRPC failed: %s\n", err)
	}
	fmt.Printf("Got response: %v\n", res)

	// Should result in three events being emitted:
	// 1) The span autogenerated by the UnaryServerInterceptor inside the gRPC server;
	// 2) The span autogenerated by the UnaryClientInterceptor inside the gRPC client; and
	// 3) The root span created on line 89.
}
