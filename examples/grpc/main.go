package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"

	"github.com/honeycombio/beeline-go"
	"github.com/honeycombio/beeline-go/trace"
	"github.com/honeycombio/beeline-go/wrappers/hnygrpc"
	"google.golang.org/grpc"

	hpb "github.com/honeycombio/beeline-go/examples/grpc/proto"
)

type grpcHelloServer struct {
	hpb.UnimplementedHelloServiceServer
}

func (hs *grpcHelloServer) SayHello(ctx context.Context, req *hpb.HelloRequest) (*hpb.HelloResponse, error) {
	return &hpb.HelloResponse{Greeting: fmt.Sprintf("Hello, %s!", req.GetName())}, nil
}

type httpHelloServer struct {
	c hpb.HelloServiceClient
}

func (hs *httpHelloServer) makeHandler() func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		res1, err := hs.c.SayHello(ctx, &hpb.HelloRequest{Name: "Foo"})
		if err != nil {
			io.WriteString(w, fmt.Sprintf("Failed gRPC: %v", err))
			return
		}
		res2, _ := hs.c.SayHello(ctx, &hpb.HelloRequest{Name: "Bar"})
		if err != nil {
			io.WriteString(w, fmt.Sprintf("Failed gRPC: %v", err))
			return
		}
		io.WriteString(w, fmt.Sprintf("%s\n%s\n", res1.GetGreeting(), res2.GetGreeting()))
	}
}

func main() {
	// Initialize beeline. The only required field is WriteKey.
	beeline.Init(beeline.Config{
		WriteKey:    "example",
		Dataset:     "beeline-example",
		ServiceName: "sample app",
		// For demonstration, send the event to STDOUT instead of Honeycomb.
		// Remove the STDOUT setting when filling in a real write key.
		// NOTE: This should *only* be set to true in development environments.
		// Setting to true in Production environments can cause problems.
		STDOUT: true,
	})
	defer beeline.Close()

	// Set up a gRPC server.
	ln, err := net.Listen("tcp", ":50051")
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}
	serverOpts := []grpc.ServerOption{
		grpc.UnaryInterceptor(hnygrpc.UnaryServerInterceptor()),
	}
	s := grpc.NewServer(serverOpts...)
	hpb.RegisterHelloServiceServer(s, &grpcHelloServer{})
	go s.Serve(ln)

	// Set up a gRPC client.
	conn, err := grpc.Dial(
		"localhost:50051",
		grpc.WithInsecure(),
		grpc.WithBlock(),
		grpc.WithUnaryInterceptor(hnygrpc.UnaryClientInterceptor()),
	)
	if err != nil {
		log.Fatalf("did not connect: %v", err)
	}
	defer conn.Close()
	c := hpb.NewHelloServiceClient(conn)

	// Set up a root trace, so we can see it get propagated across the gRPC boundary.
	ctx := context.Background()
	ctx, tr := trace.NewTrace(ctx, nil)
	defer tr.Send()

	// Finally, make some calls.
	req := &hpb.HelloRequest{Name: "Foo"}
	fmt.Printf("Making request: %v\n", req)
	res, err := c.SayHello(ctx, req)
	if err != nil {
		fmt.Printf("gRPC failed: %s\n", err)
	}
	fmt.Printf("Got response: %v\n", res)

	// Should result in three events being emitted:
	// 1) The span autogenerated by the UnaryServerInterceptor inside the gRPC server;
	// 2) The span autogenerated by the UnaryClientInterceptor inside the gRPC client; and
	// 3) The root span created on line 89.
}
